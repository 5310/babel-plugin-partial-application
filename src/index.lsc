PACKAGE_NAME = 'babel-plugin-partial-application'
DEFAULT_PLACEHOLDER = '_'
ALTERNATE_PLACEHOLDER = '__'

makeIdentifierError (path, current) ->
  path.buildCodeFrameError(
    `Cannot use placeholder as an identifier.\n
     If you need to use '${current}' as a variable name:
     - set 'options.placeholder' to a different custom token
     - set 'options.useAlternatePlaceholder' for '__'
       ( a double underscore )\n
    See https://github.com/citycide/${PACKAGE_NAME}#caveats--limitations
    for more information.\n`
  )

module.exports = ({ types: t }) ->
  let currentPlaceholder = DEFAULT_PLACEHOLDER

  getPlaceholder (state) ->
    let {
      placeholder = currentPlaceholder,
      useAlternatePlaceholder
    } = state.opts

    if placeholder == DEFAULT_PLACEHOLDER and useAlternatePlaceholder:
      now placeholder = ALTERNATE_PLACEHOLDER

    kind = typeof placeholder
    if kind != 'string':
      throw new TypeError(
        'Expected a string for `options.placeholder` ' +
        `and got ${kind}`
      )

    placeholder

  setPlaceholder (token) ->
    if typeof token == 'string':
      now currentPlaceholder = token

  getUniqueName (path, name = 'a') ->
    path.scope.generateUidIdentifier(name)

  isPlaceholder (node, placeholder) ->
    t.isIdentifier(node, { name: placeholder })

  isSpreadPlaceholder (node, placeholder) ->
    t.isSpreadElement(node) and
    isPlaceholder(node.argument, placeholder)

  isPartialCaller (node, placeholder) ->
    t.isCallExpression(node) and
    hasPlaceholders(node.arguments, placeholder)

  isPluginRequire (node) ->
    if !node: return
    { callee, arguments: args } = node

    isRequire =
      t.isIdentifier(callee, { name: 'require' }) or (
        t.isMemberExpression(callee) and
        t.isIdentifier(callee.object, { name: 'require' })
      )

    isRequire and t.isStringLiteral(args[0], { value: PACKAGE_NAME })

  shouldHoist (node) ->
    if t.isCallExpression(node):
      return !node.callee?.object?.wasPlaceholder

    if t.isMemberExpression(node):
      return !node.object.wasPlaceholder

    !t.isLiteral(node) and [
      'Identifier'
      'SpreadElement'
      'FunctionExpression'
      'ArrowFunctionExpression'
    ].every(type => type != node.type)

  hasPlaceholders (nodes, placeholder) ->
    for elem node in nodes:
      if isPlaceholder(node, placeholder):
        return true

  makeWrapperFunction (params, returnValue) ->
    t.arrowFunctionExpression(
      params,
      t.blockStatement([
        t.returnStatement(returnValue)
      ])
    )

  checkImports (path, placeholder) ->
    { node: { specifiers, source } } = path
    if source.value == PACKAGE_NAME and specifiers.length:
      setPlaceholder(specifiers[0].local.name)
      return path.remove()

    for elem specifier in specifiers:
      if specifier.local.name == placeholder:
        throw makeIdentifierError(path, placeholder)

  checkDeclarations (path, placeholder) ->
    for elem declaration in path.node.declarations:
      if isPluginRequire(declaration.init):
        if t.isIdentifier(declaration.id):
          setPlaceholder(declaration.id.name)
          return path.remove()

      if declaration.id.name == placeholder:
        throw makeIdentifierError(path, placeholder)

  appliedChildVisitor = {
    CallExpression (childPath): void ->
      childPath.skip()

    Identifier (childPath): void ->
      { node, parent } = childPath

      if !isPlaceholder(node, this.placeholder): return

      let name = 'arg'
      if t.isMemberExpression(parent):
        now name = 'obj'
        parent.wasPlaceholder = true

      id = getUniqueName(childPath, name)
      this.fn.params.push(id)
      node.name = id.name
      node.wasPlaceholder = true

    SpreadElement (childPath): void ->
      { node: { argument } } = childPath

      if !isPlaceholder(argument, this.placeholder): return

      id = getUniqueName(childPath, 'spr')
      this.fn.params.push(t.restElement(id))
      childPath.replaceWith(t.spreadElement(id))
  }

  binaryChildVisitor = {
    Identifier (childPath): void ->
      if !isPlaceholder(childPath.node, this.placeholder):
        return

      id = getUniqueName(childPath, 'bin')
      this.tail.node.params.push(id)
      childPath.node.name = id.name
  }

  templateLiteralVisitor = {
    Identifier (childPath): void ->
      if !isPlaceholder(childPath.node, this.placeholder):
        return

      id = getUniqueName(childPath, 'exp')
      childPath.node.name = id.name

      if t.isArrowFunctionExpression(this.path):
        this.path.node.params.push(id)
        return

      this.path.replaceWith(
        makeWrapperFunction([id], this.path.node)
      )

      this.path.stop()
  }

  return {
    visitor: {
      ImportDeclaration (path, state) ->
        checkImports(path, getPlaceholder(state))

      VariableDeclaration (path, state) ->
        checkDeclarations(path, getPlaceholder(state))

      CallExpression (path, state) ->
        placeholder = getPlaceholder(state)
        { arguments: args } = path.node

        if args.length and hasPlaceholders(args, placeholder):
          fn = makeWrapperFunction([], path.node)
          path.traverse(appliedChildVisitor, { fn, placeholder })

          for elem arg, idx i in args:
            if shouldHoist(arg) and !isPartialCaller(arg, placeholder):
              id = getUniqueName(path, 'ref')
              ref = t.variableDeclaration('const', [
                t.variableDeclarator(id, arg)
              ])

              parent = path.getStatementParent()
              parent.insertBefore(ref)
              args[i] = id

          path.replaceWith(fn)

      MemberExpression (path, state) ->
        placeholder = getPlaceholder(state)
        { node: { object } } = path

        if !isPlaceholder(object, placeholder): return

        let comparingPlaceholders = false
        binaryParent = path.findParent(
          p => t.isBinaryExpression(p)
        )

        ids = [getUniqueName(path, 'obj')]

        if binaryParent:
          { right } = binaryParent.node
          if isPlaceholder(right, placeholder):
            now comparingPlaceholders = true
          else:
            let target = right?.object or right?.callee?.object
            while target?.object or target?.callee:
              now target = target.object or target.callee.object

            if isPlaceholder(target, placeholder):
              now comparingPlaceholders = true
              id = getUniqueName(path, 'obj')
              ids.push(id)
              target.name = id.name

        object.name = ids[0].name

        let tail = path
        while tail.parentPath:
          parent = tail.parentPath
          isCalleeTail =
            parent.isCallExpression() and
            parent.get('callee') == tail
          hasChainedParent =
            parent.isMemberExpression() or
            parent.isBinaryExpression() or
            isCalleeTail

          if !hasChainedParent: break
          now tail = tail.parentPath

        if tail.container:
          makeWrapperFunction(ids, tail.node)
            ~tail.replaceWith()
        else:
          for elem id in ids:
            tail.parent.params.push(id)

      SpreadElement (path, state) ->
        placeholder = getPlaceholder(state)
        { parent, parentPath, node: { argument } } = path

        if !isPlaceholder(argument, placeholder): return

        if path.listKey != 'arguments':
          throw path.parentPath.buildCodeFrameError(
            'Placeholder spread is only supported as a function argument.'
          )

        id = getUniqueName(path, 'spr')

        if path.container:
          path.replaceWith(t.spreadElement(id))
          makeWrapperFunction([t.restElement(id)], parent)
            ~parentPath.replaceWith()
        else:
          parent.params.push(t.restElement(id))
          path.node.argument = id

        parentPath.stop()

      BinaryExpression (path, state) ->
        placeholder = getPlaceholder(state)
        { node: { left, right } } = path
        nodes = [left, right].filter(v => isPlaceholder(v, placeholder))

        if !nodes.length: return

        let tail = path
        while t.isBinaryExpression(tail.parent):
          now tail = tail.parentPath

        if tail.container:
          makeWrapperFunction([], t.toExpression(tail.node))
            ~tail.replaceWith()
        else:
          now tail = tail.parentPath

        tail.traverse(binaryChildVisitor, { tail, placeholder })
        tail.stop()

      TemplateLiteral (path, state) ->
        placeholder = getPlaceholder(state)
        path.traverse(templateLiteralVisitor, { path, placeholder })
    }
  }
